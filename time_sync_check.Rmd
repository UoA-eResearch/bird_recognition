---
title: "Time sync check"
output: html_notebook
---

## Load libraries

```{r message=FALSE, warning=FALSE}
library(bioacoustics)
library(tuneR)
library(seewave)
library(dplyr)
library(tidyverse)
library(lubridate)
library(tools)
library(ggplot2)
library(ggpmisc)
library(plotly)
ymd_hms = function(dt) {
  lubridate::ymd_hms(dt, tz="Pacific/Auckland")
}
dmy_hms = function(dt) {
  lubridate::dmy_hms(dt, tz="Pacific/Auckland")
}
```

## Load RFID log files

```{r}
files = list.files("data/2019 RFID", pattern = "*.TXT$", recursive = TRUE, full.names=TRUE)
csvs = lapply(files, function(path) {
  csv = read.csv(path, header=FALSE, col.names = c("year", "month", "day", "hour","minute_sec", "id", "ext", "int", "msg"))
  csv$site = strsplit(strsplit(path, "/")[[1]][4], "_")[[1]][1]
  csv
})
rfid = do.call(rbind, csvs)
rfid$datetime = paste0(rfid$year, "-", rfid$month, "-", rfid$day, " ", rfid$hour, ":", rfid$minute_sec)
rfid$datetime = ymd_hms(rfid$datetime)
ggplot(rfid, aes(datetime)) +
  geom_freqpoly(binwidth = 60 * 60)
```
### Reference spectrograms for playback files
```{r}
html_tag_audio <- function(file, type = c("wav")) {
  type <- match.arg(type)
  htmltools::tags$h3(
    basename(file),
    htmltools::tags$audio(
      controls = "",
      htmltools::tags$source(
        src = file,
        type = glue::glue("audio/{type}", type = type)
      )
    )
  )
}
files = Sys.glob("./clips/PB*.wav")
PB_wavs = lapply(files, function(f) {
  wav = read_audio(f)
  wav_length = round(length(wav) / wav@samp.rate, 2)
  spectro(wav, main=paste0(basename(f), " ", wav_length, "s"), osc=TRUE)
  print(html_tag_audio(f))
  data.frame(filename=basename(f), wav_length, stringsAsFactors = FALSE)
})
PB_wavs = do.call(rbind, PB_wavs)
```

### Build a reference dataframe showing which wave files correspond to which times

```{r}
if (file.exists("misc/BAR_timespans.csv")) {
  df = read.csv("misc/BAR_timespans.csv", stringsAsFactors = FALSE)
  df$start = ymd_hms(df$start)
  df$end = ymd_hms(df$end)
  df$interval = interval(df$start, df$end)
} else {
  files = list.files("data/2019 BAR recordings", pattern = "*.wav$", recursive = TRUE, full.names=TRUE)
  library(pbapply)
  df = pblapply(files, function(f) {
    bits = strsplit(basename(f), "_")[[1]]
    start = ymd_hms(paste(bits[2], bits[3]))
    site = strsplit(f, "/")[[1]][4]
    try({
      wav_header = readWave(f, header=TRUE)
      duration = wav_header$samples / wav_header$sample.rate
      end = start + duration
      return(data.frame(filename = f, base_filename = basename(f), site = site, start = start, end = end, interval = interval(start, end), stringsAsFactors = FALSE))
    })
    NULL
  })
  df = do.call(rbind, df)
  write.csv(df, "misc/BAR_timespans.csv")
}
df[c("site", "interval")]
```


### Select a few playback entries to check

```{r}
PB_to_check = "PB0023.wav"
filtered_rfid = filter(rfid, msg == PB_to_check & site == "NNK30")
filtered_df = filter(df, site == "NNK30")
filtered_rfid$corrected_datetime = filtered_rfid$datetime
filtered_rfid$match = lapply(1:nrow(filtered_rfid), function(i) {
  dt = filtered_rfid$corrected_datetime[i]
  site = filtered_rfid$site[i]
  indices = which(dt %within% filtered_df$interval)
  if (length(indices) == 0) indices = NA
  indices
})
print(paste("There are", nrow(filtered_rfid), PB_to_check, "playbacks, of which", sum(!is.na(filtered_rfid$match)), "have recordings"))
# A few randomly
#datetimes_to_check = sort(sample(filtered_rfid$datetime[!is.na(filtered_rfid$match)], 10))
# Ones from the 13th
#datetimes_to_check = filtered_rfid$datetime[!is.na(filtered_rfid$match) & filtered_rfid$datetime < ymd("2019-12-14")]
datetimes_to_check = filtered_rfid$corrected_datetime[!is.na(filtered_rfid$match) & filtered_rfid$corrected_datetime %within% interval(ymd_hms("2019-12-13 16:45:00"), ymd_hms("2019-12-13 17:13:00"))]
print(datetimes_to_check)
```

```{r}
#dt = ymd_hms("2019-12-13 16:45:04")
setWavPlayer("play") # OS dependent
checked_clips = lapply(datetimes_to_check, function(dt) {
  match = filtered_rfid$match[filtered_rfid$corrected_datetime == dt][[1]]
  f = filtered_df$filename[match]
  clip_start = time_length(dt - filtered_df$start[match], unit = "seconds")
  clip_end = clip_start + PB_wavs$wav_length[PB_wavs$filename == PB_to_check]
  print(paste(f, dt, clip_start, clip_end))
  wav = read_audio(f, from = clip_start, to = clip_end + 1)
  spectro(wav, main=dt, osc=TRUE)
  play(wav)
  wav
})
```

## Compare annotations with nearest RFID log

```{r}
annotations = lapply(list.files("misc", "*.txt", full.names=TRUE), function(f) {
  if (str_detect(f, "selections")) {
    x = read.table(f, sep="\t", header=TRUE, stringsAsFactors = FALSE)
    x$datetime = ymd_hms(paste(x$Begin.Date, x$Begin.Clock.Time))
    x = x[c("Begin.Time..s.", "End.Time..s.", "Individual.ID", "Nest.ID", "datetime")]
  } else {
    x = read.table(f, stringsAsFactors = FALSE, col.names = c("Begin.Time..s.", "End.Time..s.", "Individual.ID"))[c(TRUE, FALSE),]
    x$Begin.Time..s. = as.numeric(x$Begin.Time..s.)
    x$End.Time..s. = as.numeric(x$Begin.Time..s.)
    x$Nest.ID = strsplit(basename(f), "_")[[1]][1]
    x$datetime = df$start[df$base_filename == str_replace(basename(f), ".txt", ".wav")] + x$Begin.Time..s.
  }
  x$filename = substr(basename(f), start = 6, stop = 20)
  x
})
annotations = do.call(rbind, annotations)
annotations$offset = rep(NA, nrow(annotations))
annotations$rfid_offset = rep(NA, nrow(annotations))
annotations$rfid_datetime = annotations$datetime
annotations$Individual.ID[annotations$Individual.ID == "PB0009" | annotations$Individual.ID == "PB009"] = "PB0009zp"
for (i in 1:nrow(annotations)) {
  if (substring(annotations$Individual.ID[i], 0, 2) == "PB") {
    filtered_rfid = filter(rfid, annotations$Nest.ID[i] == site & msg == paste0(annotations$Individual.ID[i], ".wav"))
    matched_rec_start = df$start[df$site == annotations$Nest.ID[i] & annotations$datetime[i] %within% df$interval]
    diffs = time_length(filtered_rfid$datetime - annotations$datetime[i])
    min_i = which.min(abs(diffs))
    offset = diffs[min_i]
    if (length(offset) == 1) {
      annotations$offset[i] = offset
      annotations$rfid_offset[i] = time_length(filtered_rfid$datetime[min_i] - matched_rec_start)
      annotations$rfid_datetime[i] = filtered_rfid$datetime[min_i]
    }
  }
}
filtered_annotations = filter(annotations, !is.na(offset) & offset > -60 & Nest.ID == "NNS1")
ggplot(data = filtered_annotations, aes(x=rfid_offset, y=offset, color=filename)) +
    geom_point() +
    geom_smooth(method = "lm") +
    stat_poly_eq(formula = y ~ x,
                   aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                   parse = TRUE)
```

Something is wrong with the RFID chip clock - it's drifting significantly. More data points will help - let's autodetect PB in the audio files

```{r}
filtered_annotations = annotations[annotations$Individual.ID == "PB0023" & annotations$Nest.ID == "NNK30",]
print(filtered_annotations[1,])
library(monitoR)
PB23 = makeCorTemplate("clips/PB0023.wav", frq.lim = c(3,10), name="PB0023")
PB24 = makeCorTemplate("clips/PB0024.wav", frq.lim = c(3,10), name="PB0024")
ctemps = combineCorTemplates(PB23, PB24)
wav = read_audio(filtered_annotations$Begin.Path[1], from = 300, to = 800)
savewav(wav, filename="test.wav")
#spectro(wav, osc=TRUE)
#play(wav)
cscores <- corMatch("test.wav", ctemps, parallel = TRUE, show.prog = TRUE)
cdetects <- findPeaks(cscores)
getDetections(cdetects)
```
monitoR seems too unreliable for this task, unfortunately


The reason for the drift is SD card write speed. BAR logfiles indicate the true time packed, so if we read the BAR logfiles we can determine the true sampling rate, and correct it. In some cases, it'll be just under 44.1KHz.

```{r}
files = list.files("data/2019 BAR recordings", pattern = "logfile.txt$", recursive = TRUE, full.names=TRUE)
sites = sapply(strsplit(files, "/"), "[[", 4)
df$true_length = rep(NA, nrow(df))
for (site in unique(sites)) {
  files_for_site = files[site == sites]
  lines = unlist(lapply(files_for_site, readLines))
  rec = str_subset(lines, "Recording")
  dt = dmy_hms(str_extract(rec, "^.{19}"))
  rec = rec[order(dt)]
  dt = sort(dt)
  for (i in 1:(length(rec) - 1)) {
    if (str_detect(rec[i], "started") && str_detect(rec[i + 1], "stopped")) {
      wav_starts = df$start[site == site]
      diffs = time_length(wav_starts - dt[i])
      min_i = which.min(abs(diffs))
      df$true_length[min_i] = time_length(dt[i+1] - dt[i])
    }
  }
}
```




