---
title: "Time sync check"
output: html_notebook
---

## Load libraries

```{r message=FALSE, warning=FALSE}
# install.packages(c("bioacoustics", "tuneR", "seewave", "dplyr", "tidyverse", "lubridate", "tools", "ggplot2", "ggpmisc", "plotly", "stringr", "monitoR", "pbapply", "foreach", "doParallel", "R.utils"), type="binary")
library(bioacoustics)
library(tuneR)
library(seewave)
library(dplyr)
library(tidyverse)
library(lubridate)
library(tools)
library(ggplot2)
library(ggpmisc)
library(plotly)
library(stringr)
ymd_hms = function(dt) {
  lubridate::ymd_hms(dt, tz="Pacific/Auckland")
}
dmy_hms = function(dt) {
  lubridate::dmy_hms(dt, tz="Pacific/Auckland")
}
options(stringsAsFactors = FALSE)
```

## Load RFID log files

```{r}
files = list.files("data/2019 RFID", pattern = "*.TXT$", recursive = TRUE, full.names=TRUE)
csvs = lapply(files, function(path) {
  csv = read.csv(path, header=FALSE, col.names = c("year", "month", "day", "hour","minute_sec", "id", "ext", "int", "msg"))
  csv$site = strsplit(strsplit(path, "/")[[1]][4], "_")[[1]][1]
  csv
})
rfid = do.call(rbind, csvs)
rfid$datetime = paste0(rfid$year, "-", rfid$month, "-", rfid$day, " ", rfid$hour, ":", rfid$minute_sec)
rfid$datetime = ymd_hms(rfid$datetime)
ggplot(rfid, aes(datetime)) +
  geom_freqpoly(binwidth = 60 * 60)
```
### Reference spectrograms for playback files
```{r}
html_tag_audio <- function(file, type = c("wav")) {
  type <- match.arg(type)
  htmltools::tags$h3(
    basename(file),
    htmltools::tags$audio(
      controls = "",
      htmltools::tags$source(
        src = file,
        type = glue::glue("audio/{type}", type = type)
      )
    )
  )
}
files = Sys.glob("./clips/PB*.wav")
PB_wavs = lapply(files, function(f) {
  wav = read_audio(f)
  wav_length = round(length(wav) / wav@samp.rate, 2)
  spectro(wav, main=paste0(basename(f), " ", wav_length, "s"), osc=TRUE)
  print(html_tag_audio(f))
  data.frame(filename=basename(f), wav_length)
})
PB_wavs = do.call(rbind, PB_wavs)
```

### Build a reference dataframe showing which wave files correspond to which times

```{r}
read_BAR_metadata = function(files) {
  library(pbapply)
  df = pblapply(files, function(f) {
    bits = strsplit(basename(f), "_")[[1]]
    start = ymd_hms(paste(bits[2], bits[3]))
    site = strsplit(f, "/")[[1]][4]
    try({
      wav_header = readWave(f, header=TRUE)
      duration = wav_header$samples / wav_header$sample.rate
      end = start + duration
      return(data.frame(filename = f, base_filename = basename(f), site = site, start = start, end = end, samples = wav_header$samples, sr = wav_header$sample.rate, duration=duration, interval = interval(start, end)))
    })
    NULL
  })
  df = do.call(rbind, df)
  df
}
if (file.exists("misc/BAR_timespans.csv")) {
  df = read.csv("misc/BAR_timespans.csv")
  df$start = ymd_hms(df$start)
  df$end = ymd_hms(df$end)
  df$interval = interval(df$start, df$end)
} else {
  files = list.files("data/2019 BAR recordings", pattern = "*.wav$", recursive = TRUE, full.names=TRUE)
  df = read_BAR_metadata(files)
  write.csv(df, "misc/BAR_timespans.csv", row.names = FALSE)
}
df[c("site", "interval")]
```


### Select a few playback entries to check

```{r}
PB_to_check = "PB0023.wav"
site_to_check = "NNK30"
filtered_rfid = filter(rfid, msg == PB_to_check & site == site_to_check)
filtered_df = filter(df, site == site_to_check)
filtered_rfid$corrected_datetime = filtered_rfid$datetime
filtered_rfid$match = lapply(1:nrow(filtered_rfid), function(i) {
  dt = filtered_rfid$corrected_datetime[i]
  site = filtered_rfid$site[i]
  indices = which(dt %within% filtered_df$interval)
  if (length(indices) == 0) indices = NA
  indices
})
print(paste("There are", nrow(filtered_rfid), PB_to_check, "playbacks, of which", sum(!is.na(filtered_rfid$match)), "have recordings"))
# A few randomly
datetimes_to_check = sort(sample(filtered_rfid$corrected_datetime[!is.na(filtered_rfid$match)], 5))
# Ones from the 13th
#datetimes_to_check = filtered_rfid$corrected_datetime[!is.na(filtered_rfid$match) & filtered_rfid$datetime > ymd_hms("2019-11-20 00:00:00") & filtered_rfid$datetime < ymd_hms("2019-11-20 23:59:59")]
#datetimes_to_check = filtered_rfid$corrected_datetime[!is.na(filtered_rfid$match) & filtered_rfid$corrected_datetime %within% interval(ymd_hms("2019-12-13 16:45:00"), ymd_hms("2019-12-13 17:13:00"))]
print(datetimes_to_check)
```

```{r}
#dt = ymd_hms("2019-12-13 16:45:04")
setWavPlayer("play") # OS dependent
checked_clips = lapply(datetimes_to_check, function(dt) {
  match = filtered_rfid$match[filtered_rfid$corrected_datetime == dt][[1]]
  f = filtered_df$filename[match]
  clip_start = time_length(dt - filtered_df$start[match], unit = "seconds")
  clip_end = clip_start + 1
  print(paste(f, dt, clip_start, clip_end))
  wav = read_audio(f, from = clip_start, to = clip_end)
  spectro(wav, main=dt, osc=TRUE)
  play(wav)
  wav
})
```

## Write out a csv of approx positions of PB events per wave file

```{r}
if (file.exists("misc/approx_offsets.csv")) {
  approx_offsets = read.csv("misc/approx_offsets.csv")
} else {
  filtered_rfid = rfid[str_extract(rfid$msg, "^.{2}") == "PB",]
  approx_offsets = lapply(1:nrow(df), function(i) {
    matched_events = filtered_rfid[filtered_rfid$site == df$site[i] & filtered_rfid$datetime %within% df$interval[i],]
    if (nrow(matched_events) == 0) {
      return(NULL)
    }
    if (nrow(matched_events) > 10) {
      matched_events = sample_n(matched_events, 10)
    }
    offsets = time_length(matched_events$datetime - df$start[i])
    data.frame(filename = df$filename[i], offset = offsets, site = matched_events$site, pb = matched_events$msg, datetime = matched_events$datetime)
  })
  approx_offsets = do.call(rbind, approx_offsets)
  write.csv(approx_offsets, "misc/approx_offsets.csv", row.names = FALSE)
}
```

## Compare annotations with nearest RFID log

```{r}
annotations = lapply(list.files("misc", "*.txt", full.names=TRUE), function(f) {
  if (str_detect(f, "selections")) {
    x = read.table(f, sep="\t", header=TRUE)
    x$datetime = ymd_hms(paste(x$Begin.Date, x$Begin.Clock.Time))
    x = x[c("Begin.Time..s.", "End.Time..s.", "Individual.ID", "Nest.ID", "datetime")]
  } else {
    x = read.table(f, col.names = c("Begin.Time..s.", "End.Time..s.", "Individual.ID"))[c(TRUE, FALSE),]
    x$Begin.Time..s. = as.numeric(x$Begin.Time..s.)
    x$End.Time..s. = as.numeric(x$Begin.Time..s.)
    x$Nest.ID = strsplit(basename(f), "_")[[1]][1]
    x$datetime = df$start[df$base_filename == str_replace(basename(f), ".txt", ".wav")] + x$Begin.Time..s.
  }
  x$filename = str_replace(basename(f), ".Band.Limited.Energy.Detector.selections.txt|.txt", "")
  x
})
annotations = do.call(rbind, annotations)
annotations$offset = rep(NA, nrow(annotations))
annotations$Individual.ID[annotations$Individual.ID == "PB0009" | annotations$Individual.ID == "PB009"] = "PB0009zp"
for (i in 1:nrow(annotations)) {
  if (substring(annotations$Individual.ID[i], 0, 2) == "PB") {
    filtered_rfid = filter(rfid, annotations$Nest.ID[i] == site & msg == paste0(annotations$Individual.ID[i], ".wav"))
    matched_rec_start = df$start[df$site == annotations$Nest.ID[i] & annotations$datetime[i] %within% df$interval]
    diffs = time_length(filtered_rfid$datetime - annotations$datetime[i])
    min_i = which.min(abs(diffs))
    offset = diffs[min_i]
    if (length(offset) == 1) {
      annotations$offset[i] = offset
    }
  }
}
filtered_annotations = filter(annotations, !is.na(offset) & offset > -60 & Nest.ID == "NNS1")
ggplot(data = filtered_annotations, aes(x=Begin.Time..s., y=offset, color=substr(basename(filename), start = 6, stop = 20))) +
    geom_point() +
    geom_smooth(method = "lm") +
    stat_poly_eq(formula = y ~ x,
                   aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                   parse = TRUE) +
    labs(color='file datetime')
```

Something is wrong with the RFID chip clock - it's drifting significantly. More data points will help - let's autodetect PB in the audio files

```{r}
filtered_annotations = annotations[annotations$Individual.ID == "PB0023" & annotations$Nest.ID == "NNK30",]
print(filtered_annotations[1,])
library(monitoR)
PB23 = makeCorTemplate("clips/PB0023.wav", frq.lim = c(3,10), name="PB0023")
PB24 = makeCorTemplate("clips/PB0024.wav", frq.lim = c(3,10), name="PB0024")
ctemps = combineCorTemplates(PB23, PB24)
wav = read_audio(filtered_annotations$Begin.Path[1], from = 300, to = 800)
savewav(wav, filename="test.wav")
#spectro(wav, osc=TRUE)
#play(wav)
cscores <- corMatch("test.wav", ctemps, parallel = TRUE, show.prog = TRUE)
cdetects <- findPeaks(cscores)
getDetections(cdetects)
```
monitoR seems too unreliable for this task, unfortunately


The reason for the drift is SD card write speed. BAR logfiles indicate the true time packed, so if we read the BAR logfiles we can determine the true sampling rate, and correct it. In some cases, it'll be just under 44.1KHz.

```{r}
files = list.files("data/2019 BAR recordings", pattern = "logfile.*txt$", recursive = TRUE, full.names=TRUE)
sites = sapply(strsplit(files, "/"), "[[", 4)
df$true_length = rep(NA, nrow(df))
for (site in unique(sites)) {
  files_for_site = files[site == sites]
  lines = unlist(lapply(files_for_site, readLines))
  rec = str_subset(lines, "Recording")
  dt = dmy_hms(str_extract(rec, "^.{19}"))
  rec = rec[order(dt)]
  dt = sort(dt)
  for (i in 1:(length(rec) - 1)) {
    if (str_detect(rec[i], "started") && str_detect(rec[i + 1], "stopped")) {
      filtered_df = df[df$site == site,]
      diffs = time_length(filtered_df$start - dt[i])
      min_i = which.min(abs(diffs))
      min_i = which(df$filename == filtered_df$filename[min_i])
      df$true_length[min_i] = time_length(dt[i+1] - dt[i])
    }
  }
}
ggplot(df[df$site != "KAKA Aviary_20191101_20191113_BAR",], aes(x=start, y=true_length - duration, color = site)) +
  geom_point() + 
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10))
```

## Write out waves with corrected sampling rates

```{r eval=FALSE, include=FALSE}
library(foreach)
library(doParallel)
library(R.utils)
registerDoParallel(detectCores() - 1)
filtered_df = df[!is.na(df$true_length) & df$true_length > 100 & df$site %in% unique(rfid$site),]
foreach(i = 1:nrow(filtered_df), .packages = "tuneR")  %dopar% {
  output_filename = str_replace(filtered_df$filename[i], "2019 BAR recordings", "2019 BAR recordings - fixed SR")
  if (!file.exists(output_filename)) {
    wav = readWave(filtered_df$filename[i])
    wav@samp.rate = round(length(wav) / filtered_df$true_length[i])
    mkdirs(dirname(output_filename))
    writeWave(wav, filename = output_filename)
  }
}
```

The problem with that though, is that sampling rates in wave files are integers - there's a loss of precision there. It should be possible to multiply a desired second offset by the true sampling rate and slice a wav file that way.

```{r}
df$true_sr = df$samples / df$true_length
write.csv(df, "misc/BAR_timespans.csv", row.names = FALSE)
ggplot(df[df$duration > 100,], aes(x=true_sr)) +
  geom_histogram(binwidth=5)
```
```{r}
approx_offsets$corrected_offset = sapply(1:nrow(approx_offsets), function(i) {
  approx_offsets$offset[i] * 44100 / df$true_sr[approx_offsets$filename[i] == df$filename]
})
write.csv(approx_offsets, "misc/approx_offsets.csv", row.names = FALSE)
```


```{r}
filtered_offsets = approx_offsets[approx_offsets$site == "NNS1" & approx_offsets$filename %in% df$filename[!is.na(df$true_sr)],]
for (i in sample(1:nrow(filtered_offsets), 10)) {
  f = filtered_offsets$filename[i]
  true_sr_for_f = df$true_sr[df$filename == f]
  clip_start = round(filtered_offsets$offset[i] * true_sr_for_f)
  clip_end = round(clip_start + true_sr_for_f)
  print(paste(f, true_sr_for_f, clip_start, clip_end))
  wav = readWave(filename = f, from = clip_start, to = clip_end, units="samples")
  wav@samp.rate = true_sr_for_f
  spectro(wav, main=basename(f), osc=TRUE)
  play(wav)
}
```

```{r}
annotations$corrected_begin = sapply(1:nrow(annotations), function(i) {
  true_sr = df$true_sr[str_detect(df$base_filename, fixed(annotations$filename[i]))]
  annotations$Begin.Time..s.[i] * 44100 / true_sr
})
annotations$offset = NA
for (i in 1:nrow(annotations)) {
  if (substring(annotations$Individual.ID[i], 0, 2) == "PB") {
    filtered_rfid = filter(rfid, annotations$Nest.ID[i] == site & msg == paste0(annotations$Individual.ID[i], ".wav"))
    matched_rec_start = df$start[str_detect(df$base_filename, fixed(annotations$filename[i]))]
    rfid_offset = time_length(filtered_rfid$datetime - matched_rec_start)
    diffs = time_length(annotations$corrected_begin[i] - rfid_offset)
    min_i = which.min(abs(diffs))
    offset = diffs[min_i]
    if (length(offset) == 1) {
      annotations$offset[i] = offset
    }
  }
}
filtered_annotations = filter(annotations, Nest.ID == "NNS1" & abs(offset) < 60)
ggplot(data = filtered_annotations, aes(x=corrected_begin, y=offset, color=substr(basename(filename), start = 6, stop = 20))) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
    labs(color='file datetime') #+
    #stat_poly_eq(formula = y ~ x,
                   #aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                   #parse = TRUE)
ggplot(data = annotations, aes(x=corrected_begin, y=offset, color=Nest.ID)) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 10))
```

